\chapter{整数を扱うデータ構造}

この章では#SSet#の実装を再び扱う。
ただしここでは#SSet#の要素は#w#ビットの整数だと仮定する。
すなわち$#x#\in\{0,\ldots,2^{#w#}-1\}$について#add(x)#・#remove(x)#・#find(x)#を実装する。
データやキーが整数である応用は明らかにたくさんあるだろう。

以上のことをふまえた3つのデータ構造についてこの章では説明する。
一つ目は#BinaryTrie#であり、これは#SSet#の3つの操作をいずれも$O(#w#)$の時間で実行する。
これにはさほど驚かないかもしれない。
$\{0,\ldots,2^{#w#}-1\}$の部分集合の大きさは$#n#\le 2^{#w#}$であり、$\log #n# \le #w#$が成り立つためだ。
この本で説明した#SSet#の実装は各操作の実行時間が$O(\log #n#)$であった。
すなわち、いずれも#BinaryTrie#と同じくらいは高速であった。

二つ目は#XFastTrie#であり、これは#BinaryTrie#の検索をハッシュ法を利用して高速化するものである。
この高速化により、#find(x)#の実行時間は$O(\log #w#)$になる。
しかし#XFastTrie#における#add(x)#・#remove(x)#の実行時間は依然として$O(#w#)$であり、領域使用量は$O(#n#\cdot#w#)$である。

三つ目は#YFastTrie#であり、これは#XFastTrie#に約$#w#$個にひとつのサンプルを格納し、それ以外をふつうの#SSet#に格納するデータ構造である。
この工夫により#add(x)#・#remove(x)#の実行時間は$O(\log #w#)$に、領域使用量は$O(#n#)$に抑えられる。

この章における実装例は整数と対応付けられる任意の型のデータを格納できる。
サンプルコードにおける#ix#は#x#に対応する整数を表し、#intValue(x)#は#x#を#ix#に変換するメソッドであるとする。
しかし、文章中においては単に#x#が整数であるかのように扱う。
