\chapter{整列アルゴリズム}
\chaplabel{sorting}

この章では#n#個の要素の集合を整列するアルゴリズムを紹介する。
データ構造の教科書にこの題材が入っているのは変に思うかもしれないが、これにはいくつか理由がある。
例えばここで紹介する整列アルゴリズム（クイックソートとヒープソート）はこれまでに学んだデータ構造と深い関係がある。（ランダム二分探索木とヒープ）

最初の小節では比較だけを使った整列アルゴリズムであって、実行時間が$O(#n#\log #n#)$であるものを3つ紹介する。
またこれらの3つはいずれも漸近的に最適であることも示す。
つまり比較だけを使うアルゴリズムでは、最低でも$#n#\log#n#$回程度の比較が最悪の場合でも、また平均的な場合であっても必要なのである。


ここで、これまでの章で説明した#SSet#や優先度付き#Queue#の実装はいずれも$O(#n#\log #n#)$の時間で整列アルゴリズムを実装するのに使えることを注意しておく。
例えば#n#個の要素を、#BinaryHeap#または#MeldableHeap#における#n#回の#add(x)#に続く#n#回の#remove()#操作で整列できる。
代わりに#n#回の#add(x)#を二分探索木のどれかに実行し、そのあと行きがけ順（\excref{tree-traversal}）で要素を整列された順に取り出すことができる。
しかしいずれの場合も完全に活用するわけでないデータ構造を構築するための無駄がかなり生じる。
整列は重要な問題なので、可能な限り速く・単純で・省メモリな手法を開発する価値がある。

この章の後半では比較以外の操作も使える場合には話が変わることを見ていく。
実際に配列のランダムアクセスを使って、$\{0,\ldots,#n#^c-1\}$の要素である#n#個の整数の整列を$O(c#n#)$の時間で実行できることを説明する。
