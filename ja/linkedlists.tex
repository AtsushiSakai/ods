\chapter{連結リスト}
\chaplabel{linkedlists}

\index{linked list}%
この章でも#List#インターフェースの実装を扱うが、次は配列ではなくポインタを使ったデータ構造の話をする。
この章のデータ構造は、要素を含むノードから構成される。
参照（ポインタ）を使ってノードを繋げて列を作る。
まずは単方向連結リストを紹介する。
これを使って#Stack#・(FIFO)#Queue#の操作を定数時間で実行できる。
次に双方向連結リストを紹介する。
これを使うと#Deque#の操作を定数時間で実行できる。

連結リストを使って#List#インターフェースの実装するのは、配列を使う場合と比べて長所・短所がある。
どんな要素の#get(i)#・#set(i,x)#も定数時間で行えるわけではないのが主な短所だ。
その代わりに#i#番目の要素までリストをひとつずつ辿らなければならないのである。
一方でより動的であることが主な長所だ。
ノードの参照#u#があれば、#u#を削除したり、#u#の隣にノードを挿入したりを定数時間で実行できる。
これが#u#がリストの中のどのノードであっても成り立つのだ。

\section{SLList：単方向連結リスト}
\seclabel{sllist}

\index{SLList@#SLList#}%
\index{linked list!singly-}%
\index{singly-linked list}%

#SLList#（singly-linked list、単方向連結リスト）は#Node#の列である。
ノード#u#はデータ#u.x#と参照#u.next#を保持している。
参照は列における次のノードを指している。
列の末尾のノード#w#においては$#w.next# = #null#$である。

% TODO: Remove constructors from SLList.Node
\javaimport{ods/SLList.Node}
\cppimport{ods/SLList.Node}

効率のため#SLList#は変数#head#・#tail#で列の先頭・末尾のノードを保持している。
また#n#は列の長さを表している。
\codeimport{ods/SLList.head.tail.n}
#SLList#における#Stack#・#Queue#操作を\figref{sllist}に示した。

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/sllist}
  \end{center}
  \caption[A sequence of Queue and Stack operations on an SLList]{A sequence of #Queue# (#add(x)# and #remove()#) and #Stack# (#push(x)# and #pop()#) operations on an #SLList#.}
  \figlabel{sllist}
\end{figure}

#SLList#を使って#Stack#の#push(x)#・#pop()#を効率的に実装できる。
列の先頭に追加・削除すればよいのである。
#push(x)#は新しいノード#u#を作り、データ値に#x#を設定し、#u.next#を古い先頭とし、#u#を新しい先頭にする。
最後に#SLList#の要素がひとつ増えたので、#n#を1だけ大きくする。

\codeimport{ods/SLList.push(x)}

#pop()#では、#SLList#がから出ないことを確認し、$#head=head.next#$として先頭を削除し、#n#を1だけ小さくする。
最後の要素が削除される場合は特別で、#tail#を#null#に設定する必要がある。

\codeimport{ods/SLList.pop()}

明らかに#push(x)#・#pop()#の実行時間はいずれも$O(1)$である。

\subsection{キュー操作}

#SLList#を使ってFIFOキューの操作#add(x)#・#remove()#を定数時間で実行することもできる。
削除はリストの先頭から行われるので、#pop()#と同じである。

\codeimport{ods/SLList.remove()}

一方で追加はリストの末尾に対して行う。
#u#を新たに加えるノードとすると、ほとんどの場合は$#tail.next#=#u#$とすればよい。
しかし$#n#=0$の場合は特別で、代わりに$#tail#=#head#=#null#$とする必要がある。
この場合、#tail#も#head#も#u#になるのだ。

\codeimport{ods/SLList.add(x)}

明らかに#add(x)#・#remove()#はいずれも定数時間で実行できる。

\subsection{要約}

次の定理は#SLList#の性能を整理したものである。

\begin{thm}\thmlabel{sllist}
  #SLList#は#Stack#・(FIFO) #Queue#インターフェースの実装である。
  #push(x)#・#pop()#・#add(x)#・#remove()#の実行時間はいずれも$O(1)$である。
\end{thm}

#SLList#は#Deque#の操作をほぼすべて実装している。
足りないのは#SLList#の末尾を削除する操作だ。
#SLList#の末尾を削除するのは難しいが、これは新しい末尾を現在の末尾のひとつ前のノードに設定しなければならないためである。
末尾のひとつ前のノード#w#とは$#w.next#=#tail#$であるもののことだ。
困ったことに#w#を見つけるには#SLList#を#head#から順に$#n#-2$個のノードを辿っていかなければならないのである。
