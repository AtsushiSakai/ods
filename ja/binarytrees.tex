\chapter{二分木}
\chaplabel{binarytrees}

この章ではコンピュータサイエンスで最も基本的な構造のうちのひとつである二分木を紹介する。
\emph{木}と呼ばれるのは図示した場合の構造が（森に生えてる）木に似ているためである。
\index{tree}%
\index{tree!binary}%
\index{binary tree}%
二分木の定義は複数ある。
数学的には\emph{二分木}とは連結な有限無向グラフであって、サイクルがなく、すべての頂点の次数が2以下であるものである。

コンピュータサイエンスでの二分木には\emph{根付き}である。
\index{tree!rooted}%
\index{rooted tree}%
次数2以下の特別なノード#r#を、木の\emph{根}と呼ぶ。
すべてのノード$#u#(\neq #r#)$について#u#から#r#に向かう経路上の二番目のノードを#u#の\emph{親}という。
\index{parent}%
それ以外の#u#に隣接するノードを#u#の\emph{子}と呼ぶ。
\emph{順序付けられた}二分木に興味がある事が多い。
\index{ordered tree}%
\index{tree!ordered}%
これは\emph{左の子}と\emph{右の子}を区別するということだ。
\index{left child}%
\index{child!left}%
\index{right child}%
\index{child!right}%

図示するとき、二分木はふつう根から下に向かって書かれる。
根が一番上にあり、左右の子はそれぞれ左下・右下に書かれる。
（\figref{bintree-orientation}）
例えば\figref{binary-tree}.a は9個のノードを持つ二分木である。

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/bintree-traverse-1} 
  \end{center}
  \caption[Parent, left child, and right child]{The parent, left child, and right child of the node #u#
    in a #BinaryTree#.}
  \figlabel{bintree-orientation}
\end{figure}


\begin{figure}
  \begin{center}
    \begin{tabular}{cc}
      \includegraphics[width=\HalfScaleIfNeeded]{figs/bintree-1} &
      \includegraphics[width=\HalfScaleIfNeeded]{figs/bintree-2} \\
      (a) & (b)
    \end{tabular}
  \end{center}
  \caption{A binary tree with (a)~nine real nodes and (b)~ten external nodes.}
  \figlabel{binary-tree}
\end{figure}

二分木は重要なので、そのための専用の語彙がいくつかある。
二分木におけるノード#u#の\emph{深さ}とは、
\index{depth}%
#u#から根までの経路の長さである。
ノード#w#が#u#から#r#へのパスに含まれるとき、#w#は#u#の\emph{祖先}と呼ばれる。
\index{ancestor}%
一方#u#は#w#の\emph{子孫}と呼ばれる。
\index{descendant}%
二分木によけるノード#u#の\emph{部分木}とは、#u#を根とし、#u#のすべての子孫を含む二分木である。
ノード#u#の\emph{高さ}とは、#u#から#u#の子孫へのパスの長さの最大値である。
\index{height!in a tree}
木の\emph{高さ}とはその根の高さである。
\index{height!of a tree}%
ノード#u#が子を持たないとき、#u#は\emph{葉}である。
\index{leaf}%

\emph{外部ノード}を考えると便利なことがある。
左の子を持たないノードは外部ノードを左の子として持ち、同様に右の子を持たないノードは外部ノードを右の子として持つとする。（\figref{binary-tree}.bを参照）
帰納法により、$#n#\ge 1$個の（本物の）ノードを持つ二分木は$#n#+1$個の外部ノードを持つことを示せる。

\section{#BinaryTree#：基本的な二分木}

\index{BinaryTree@#BinaryTree#}%
二分木のノード#u#を表す最も単純なやり方は、明示的に（3つ以下の）隣接するノードを保持することだ。
\javaimport{ods/BinaryTree.BTNode<Node}
\cppimport{ods/BinaryTree.BTNode}
隣接する頂点が3つもないときはそこには#nil#を入れる。
こうすれば外部ノードと根の親が#nil#に対応することになる。

すると、二分木自体は根#r#への参照として表現できる。
\codeimport{ods/BinaryTree.r}

ノード#u#の深さは#u#から根への経路をたどるときのステップ数である。
\codeimport{ods/BinaryTree.depth(u)}


\subsection{Recursive Algorithms}

\index{recursive algorithm}%
再帰アルゴリズムを使うと二分木に関する計算が簡単になる。
例えば#u#を根とする二分木のサイズ（ノードの数）は、#u#の子を根とする部分木のサイズを最適に計算し、足し合わせると求まる。

\codeimport{ods/BinaryTree.size(u)}

ノード#u#の高さは#u#のふたつの部分木の高さの最大値を計算し、それに1加えると求まる。

\codeimport{ods/BinaryTree.height(u)}

\subsection{Traversing Binary Trees}
\seclabel{bintree:traversal}

\index{traversal!of a binary tree}%
\index{tree traversal}%
\index{binary-tree traversal}%
先の小節で説明したふたつのアルゴリズムは二分木のすべてのノードを訪問するために再帰を使った。
いずれのアルゴリズムも二分木のノードを次のコードと同じ順番で訪問していた。
\codeimport{ods/BinaryTree.traverse(u)}

このように再帰を使うと、短くて単純なコードを書けるが、これには問題もある。
再帰の深さの最大値は二分木の深さの最大値、すなわち木の高さである。
木の高さが非常に大きいと、この再帰は利用できるスタックの量以上の領域を要求し、プログラムがクラッシュしてしまう。

再帰なしで二分木を辿るためには、どこから来たかに基づき次の行き先を決めるアルゴリズムを使える。
\figref{bintree-traverse}を見よ。
ノード#u#に#u.parent#から来たときは、次は#u.left#に向かう。
#u.left#から来たときは、次は#u.right#に向かう。
#u.right#から来たときは、#u#の部分木は辿り終えたので#u.parent#に戻る。
次のコードはこれを実装したものである。
ただし、#u.left#・#u.right#・#u.parent#が#nil#であるケースも適切に処理している。
\codeimport{ods/BinaryTree.traverse2()}

\begin{figure}
  \begin{center}
    \begin{tabular}{cc}
      \includegraphics[scale=0.90909]{figs/bintree-traverse-2}
      \includegraphics[scale=0.90909]{figs/bintree-3}
    \end{tabular}
  \end{center}
  \caption[Traversing a BinaryTree]{The three cases that occur at node
    #u# when traversing a binary tree non-recursively, and the resultant
    traversal of the tree.}
  \figlabel{bintree-traverse}
\end{figure}

再帰アルゴリズムで計算できることは、こうして再帰なしでも計算できる。
例えば木のサイズを計算するためには、カウンタ#n#を保持し、新しいノードを訪問するたびにその値をひとつずつ増やせばよい。
\codeimport{ods/BinaryTree.size2()}

二分木の実装には、#parent#を使わないものもある。
この場合、再帰でない実装はやはり可能だが、#List#か#Stack#を使って今見ているノードから根までの経路を記録する必要がある。


これまで説明したものとは別の辿り方は\emph{幅優先}なものである。
\index{breadth-first traversal}%
\index{traversal!breadth-first}%
幅優先でノードを辿る場合、根から深さごとに下に向かって、同じ深さのものは左から順に、すべてのノードは訪問される。
（\figref{bintree-bfs}を参照せよ。）
XXX: どういう意味だろう
これは英語の文章読み方と似ている。
幅優先の巡回はキュー#q#を使って実装できる。
はじめは#q#は根だけを含む。
ステップごとに次のノード#u#を#q#から取り出し、#u#を処理し、#u.left#と#u.right#を（#nil#じゃなければ）#q#に加える。
\codeimport{ods/BinaryTree.bfTraverse()}

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/bintree-4}
  \end{center}
  \caption{During a breadth-first traversal, the nodes of a binary tree
  are visited
level-by-level, and left-to-right within each level.}
  \figlabel{bintree-bfs}
\end{figure}

\section{#BinarySearchTree#：バランスされていない二分探索木}
\seclabel{binarysearchtree}

\index{BinarySearchTree@#BinarySearchTree#}%
\index{binary search tree}%
\index{binary tree!search}%
#BinarySearchTree#はある性質を持つ二分木である。
ノード#u#はデータ#u.x#を持ち、このデータはある全順序な集合の要素である。
二分探索木の各ノードとそのデータは次の\emph{二分探索木性}を満たす。
\index{binary search tree property}%
ノード#u#について、#u.left#を根とする部分木に含まれるデータはすべて#u.x#より小さく、#u.right#を根とする部分木に含まれるデータはすべて#u.x#より大きい。
#BinarySearchTree#の例を\figref{bst}に示す。

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/bst-example}
    %\includegraphics[scale=0.90909]{figs/binary-tree-4}
  \end{center}
  \caption{A binary search tree.}
  \figlabel{bst}
\end{figure}


\subsection{探索}

\index{search path!in a binary search tree}%
二分探索木性は非常に有用である。
この性質を利用して二分探索木から値#x#の位置を高速に特定できる。
具体的には、根#r#から#x#を探し始める。
ノード#u#にいるとき、次の3つの場合がありうる。
\begin{enumerate}
\item $#x#< #u.x#$なら#u.left#に進む。
\item $#x#> #u.x#$なら#u.right#に進む。
\item $#x#= #u.x#$なら#u#の値は#x#である。
\end{enumerate}
この探索は三つ目のケースか、#u=nil#になると終了する。
前者なら#x#を見つけたことになる。
後者なら#x#が二分探索木には入っていなかったとわかる。
\codeimport{ods/BinarySearchTree.findEQ(x)}

Two examples of searches in a binary search tree are shown in
二分探索木における探索の例をふたつ\figref{bst-search}に示す。
二つ目の例として#x#が見つからない場合にも、役に立つ情報が得られることを示している。
探索における最後のノード#u#で先の場合分けの一つ目のケースだったなら、#u.x#は木に含まれるデータであって#x#よりも大きい値のうち、最小のものである。
同様に場合分けの二つ目のケースだったなら、#u.x#は#x#より小さい値のうち、最大のものである。
よって場合分けの一つ目のケースが発生した最後のノード#z#を保持しておけば、#BinarySearchTree#の#find(x)#操作は、#x#以上の値のうち最小の値を返すように実装することもできる。
\codeimport{ods/BinarySearchTree.find(x)}

\begin{figure}
  \begin{center}
    \begin{tabular}{cc}
    \includegraphics[width=\HalfScaleIfNeeded]{figs/bst-example-2} &
    \includegraphics[width=\HalfScaleIfNeeded]{figs/bst-example-3} \\
    (a) & (b)
    \end{tabular}
  \end{center}
  \caption{An example of (a)~a successful search (for $6$) and (b)~an unsuccessful search (for $10$) in a binary search tree.}
  \figlabel{bst-search}
\end{figure}


\subsection{Addition}

#BinarySearchTree#に値#x#を追加するためには最初に#x#を検索する。
もし見つかれば挿入する必要がない。
そうでなければ、検索において最後に出会ったノード#p#の子である葉として、#x#を保存する。
新しいノードが#p#の右の子か左の子かは#x#と#p.x#の比較結果によって決める。
\codeimport{ods/BinarySearchTree.add(x)}
\codeimport{ods/BinarySearchTree.findLast(x)}
\codeimport{ods/BinarySearchTree.addChild(p,u)}
\figref{bst-insert}に例を示した。
最も時間がかかるのは#x#を検索する処理で、この時間は新たに追加するノード#u#の高さに比例する。
最悪の場合にはこれは#BinarySearchTree#の高さである。


\begin{figure}
  \begin{center}
    \begin{tabular}{cc}
    \includegraphics[width=\HalfScaleIfNeeded]{figs/bst-example-4} &
    \includegraphics[width=\HalfScaleIfNeeded]{figs/bst-example-5} 
    \end{tabular}
  \end{center}
  \caption{Inserting the value $8.5$ into a binary search tree.}
  \figlabel{bst-insert}
\end{figure}


\subsection{Removal}

#BinarySearchTree#から値#u#を削除する処理はもう少し複雑だ。
#u#が葉なら#u#を単に親から切り離すだけでよい。
#u#がひとつだけの子を持つなら#u#の点を継ぎ合せる、すなわち#u.parent#と#u#の子を新たに親子関係とすればよい。
（\figref{bst-splice}を参照せよ。）
\codeimport{ods/BinarySearchTree.splice(u)}

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/bst-splice}
  \end{center}
  \caption{Removing a leaf ($6$) or a node with only one child ($9$) is easy.}
  \figlabel{bst-splice}
\end{figure}

#u#がふたつの子を持つ場合はもっと手の込んだことをする必要がある。
この場合、子の数が1以下で、#w.x#と#u.x#を入れ替えても大丈夫なノード#w#を見つけるのが最も単純なやり方だ。
二分探索木性を保つためには、#w.x#が#u.x#より大きい中で最小の値であれば十分である。
このような#w#を見つけるのは簡単である。
これは#u.right#を根とする部分木の中で最小の値である。
このノードは左の子を持たないため、取り除くのは簡単である。
（\figref{bst-remove}を参照せよ。）
\javaimport{ods/BinarySearchTree.remove(u)}
\cppimport{ods/BinarySearchTree.remove(u)}
\pcodeimport{ods/BinarySearchTree.remove_node(u)}

\begin{figure}
  \begin{center}
    \begin{tabular}{cc}
    \includegraphics[width=\HalfScaleIfNeeded]{figs/bst-delete-1}
    \includegraphics[width=\HalfScaleIfNeeded]{figs/bst-delete-2}
    \end{tabular}
  \end{center}
  \caption[Deleting from a BinarySearchTree]{Deleting a value ($11$) from a node, #u#, with two children is done by replacing #u#'s value with the smallest value in the right subtree of #u#.}
  \figlabel{bst-remove}
\end{figure}

\subsection{要約}

#BinarySearchTree#における#find(x)#・#add(x)#・#remove(x)#操作はいずれも根からあるノードを見つけることに関連している。
木の形状についてなにか仮定しない限り、この探索経路の長さについて「木の中のノード数より短い」ことよりも有用なことを言うのは難しい。
次の（あまりパッとしない）定理は#BinarySearchTree#の性能をまとめたものだ。

\begin{thm}\thmlabel{bst}
  #BinarySearchTree#は#SSet#インターフェースの実装であって、#add(x)#・#remove(x)#・#find(x)#の実行時間は$O(#n#)$である。
\end{thm}

\thmref{bst}は\thmref{skiplist}と比べるとショボい。
#SkiplistSSet#は#SSet#インターフェースの操作を期待実行時間$O(\log #n#)$で実装していた。
#BinarySearchTree#の問題は木の形状が\emph{アンバランス}かもしれないことだ。
\figref{bst}のようではなく、ほとんどのノードがひとつの子だけを持ち、#n#個のノードの長いチェインみたいな見た目をしているかもしれないのである。

アンバランスな二分探索木を避ける方法はたくさんあり、いずれも実行時間$O(\log #n#)$での操作を可能にする。
\chapref{rbs}で\emph{期待実行時間}$O(\log #n#)$を、ランダム性を利用して達成する方法を説明する。
\chapref{scapegoat}では\emph{償却実行時間}$O(\log #n#)$を、部分的な再構築を利用して達成する方法を説明する。
\chapref{redblack}では\emph{最悪実行時間}$O(\log #n#)$を、4つまで子を持ちうる木をシミュレートすることで達成する方法を説明する。
