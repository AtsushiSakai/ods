\chapter{赤黒木}
\chaplabel{redblack}

\index{binary search tree!red-black}%
\index{red-black tree}%
この章では赤黒木という高さを対数程度に抑える二分木を紹介する。
赤黒木は最も広く使われるデータ構造のうちのひとつである。
例えば、多くのライブラリの実装における基本的なデータ構造であり、JavaのコレクションフレームワークやC++の標準テンプレートライブラリ（のいくつかの実装）に使われている。
また、OSであるLinuxのカーネルにも使われている。
赤黒木が人気である理由を挙げる。
\begin{enumerate}
\item #n#個の値を持つ赤黒木の高さは$2\log #n#$以下である
\item #add(x)#・#remove(x)#を\emph{最悪の場合でも}$O(\log #n#)$の時間で実行できる
\item #add(x)#・#remove(x)#における、回転の回数は償却すると定数である
\end{enumerate}
はじめのふたつの性質が#Skiplist#・#Treap#・#Scapegoat#に対する赤黒木の優位性を示している。
#Skiplist#・#Treap#はランダム化を使うため実行時間$O(\log #n#)$は期待値にすぎない。
Scapegoat treeには高さの保証があるものの、#add(x)#・#remove(x)#の実行時間$O(\log #n#)$は償却実行時間にすぎない。
3つめの性質はおまけである。
要素#x#の追加・削除に必要な主要な時間は#x#を見つける処理によることを明らかにする。
\footnote{スキップリストや#Treap#も平均的にだがこの声質を持っている。
\ref{exc:skiplist-changes}と\ref{exc:treap-rotates}を参照せよ。}

しかし、赤黒木のよい性質には代償もある。
これは実装の複雑さである。
高さの上界を$2\log #n#$に保つのは容易ではない。
様々な場合についての慎重な解析が必要なのである。
すべての場合において、確実に正しい実行をしなければならないのである。
ひとつ回転を間違えたり、色を間違えると、わかりにくいバグが発生するのである。

赤黒木の実装に直接取り掛かるのでなく、関連するデータ構造である2-4木についての背景知識をまずは説明する。
こうするとどうやって赤黒木が発見され、なぜこのデータ構造を効率的に管理できるのかを理解する助けになるだろう。
