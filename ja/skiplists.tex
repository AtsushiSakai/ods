\chapter{スキップリスト}
\chaplabel{skiplists}

この章ではスキップリストという面白くて実際の応用も多いデータ構造を紹介する。
スキップリストは#get(i)#・#set(i,x)#・#add(i,x)#・#remove(i)#をいずれも$O(\log n)$の時間で実行できる#List#の実装である。
#SSet#の実装でもあり、すべての操作の期待実行時間は$O(\log #n#)$である。

スキップリストの効率性のキモはランダム性である。
新しい要素を追加するとき、スキップリストではランダムにコインを投げて要素の高さを決める。
スキップリストの性能は期待実行時間とパス長を使って表現できる。
コイントスの結果に応じて決まる確率からこの期待値は計算される。
ランダムなコイントスは擬似乱数（あるいはランダムビット）生成器によるシミュレーションで実装される。

\section{基本的な構造}

\index{skiplist}%
イメージとしてはスキップリストは単方向連結リストが並んだもの$L_0,\ldots,L_h$である。
リスト$L_r$は$L_{r-1}$の部分集合を含む。
まず#n#個の要素を含む入力$L_0$がある。
$L_0$から$L_1$を作り、$L_1$から$L_2$を作り、というのを繰り返す。
$L_{r-1}$の各要素についてコインを投げ、表が出たら$L_r$はこれを含む。
リスト$L_r$が空ならこの繰り返しを終える。
スキップリストの例を\figref{skiplist}に示した。

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist}
  \end{center}
  \caption{A skiplist containing seven elements.}
  \figlabel{skiplist}
\end{figure}

スキップリストの要素#x#について、#x#の\emph{高さ}を
For an element, #x#, in a skiplist, we call the \emph{height}
\index{height!of a skiplist}%
#x#を含むリスト$L_r$の添え字#r#のうち最大のものと定義する。
例えば#x#が$L_0$だけに含まれているなら#x#の高さは$0$である。
少し考えると#x#は次の試行と関連していることがわかるだろう。

コインを裏が出るまで繰り返し投げる。表は何回出るだろうか。
この答え、そして高さの期待値は1である。（コイントスの回数の期待値は2回だが、最後のトスは表でないため表が出る回数の期待値は1だ。）
スキップリストの\emph{高さ}とは、最も高いノードの高さである。

すべてのリストの先頭は特別で、\emph{番兵}と呼ばれる。
\index{sentinel node}%
これはリストのダミーノードのようなものだ。
スキップリストの重要な性質は、\emph{探索経路}と呼ばれる
\index{search path!in a skiplist}%
$L_h$の番兵から$L_0$の各ノードまでの短いパスが存在することだ。
ノード#u#へのパスの作り方は簡単だ。（\figref{skiplist-searchpath}を参照のこと。）
左上の端（$L_h$の番兵）からスタートし、#u#を通り過ぎない限り右に進む。
#u#を通り過ぎてしまう場合はその代わりに下に進む。

もうすこし正確に説明する。
$L_h$の番兵#w#から$L_0$のノード#u#への探索経路を見つける。
まず#w.next#を見て、これが$L_0$の中で#u#より前にあれば$#w#=#w.next#$とする。
そうでなければ、ひとつ下のリストに下がり、$L_{h-1}$の#w#から処理を続ける。
これを$L_0$における#u#の直前の要素にたどり着くまで繰り返す。
\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-searchpath}
  \end{center}
  \caption{The search path for the node containing $4$ in a skiplist.}
  \figlabel{skiplist-searchpath}
\end{figure}

次の補題はsecref{skiplist-analysis}で証明するが、探索経路が非常に短いことを主張する。

\begin{lem}\lemlabel{skiplist-searchpath}
$L_0$の任意のノード#u#への探索経路の長さの期待値は$2\log #n# + O(1) = O(\log #n#)$以下である。
\end{lem}

空間効率のよいスキップリストの実装方法を説明する。
ノード#u#はデータ#x#・ポインタの配列#next#を含む。
#u.next[i]#で$L_{#i#}$における#u#の次のノードを指せばよい。
こうすると#x#は複数のリストに現れるかもしれないが、ノードとしての実体はひとつだけあれば済む。

\javaimport{ods/SkiplistSSet.Node<T>}
\cppimport{ods/SkiplistSSet.Node}

この章の続くふたつの節ではスキップリストの応用をそれぞれ紹介する。
そこでは$L_0$が主な構造（リストや整列された集合）を保持する。
違いはどのように探索経路を辿り方である。
下に進んで$L_{r-1}$に移るか、$L_r$の中で右に進むかの選び方に違いがあるのである。

\section{#SkiplistSSet#：効率的な#SSet#}
\seclabel{skiplistset}

\index{SkiplistSSet@#SkiplistSSet#}%
#SkiplistSSet#はスキップリストを使った#SSet#インターフェースの実装である。
ここでは、$L_0$は#SSet#の要素を整列して格納する。
#find(x)#は探索経路に沿って$#y#\ge#x#$を満たす最小の#y#を探す。

\codeimport{ods/SkiplistSSet.find(x).findPredNode(x)}

#y#の探索経路を辿るのは簡単だ。
$L_{#r#}$の中のノード#u#にいるとすると、まず右隣#u.next[r].x#を見る。
$#x#>#u.next[r].x#$なら$L_{#r#}$の中で右に進む。
そうでないなら$L_{#r#-1}$に下がる。
各ステップ（右または下に進む）は一定の時間で実行できる。
よって\lemref{skiplist-searchpath}より#find(x)#の期待実行時間は$O(\log #n#)$である。

#SkipListSSet#に要素を追加する方法の前に、新しいノードの高さ#k#を決めるためのコイントスをシミュレートする方法を考える。
ランダムな整数#z#を生成し、#z#の2進数表現において連続する1の数を数える。
\footnote{この方法はコイントスを完全に再現しているわけではない。なぜなら#k#は#int#のビット数より常に小さいからである。しかし要素数が$2^{32}=4294967296$を越える場合でもない限り、この影響は無視できるほど小さい。}

\codeimport{ods/SkiplistSSet.pickHeight()}

#SkiplistSSet#の#add(x)#の実装は、#x#を入れる場所を見つけ、高さ#k#を#pickHeight()#で決め、#x#を$L_0$,\ldots,$L_{#k#}$に継ぎ合せる。
これを実現する最も簡単な方法は、リスト$L_{#r#}$からリスト$L_{#r#-1}$に下がるノードを記録する配列#stack#を使うことだ。
より正確にいうと、#stack[r]#は$L_{#r#}$内の$L_{#r#-1}$に下がるパスのあるノードである。
#x#を挿入する時に修正する必要のあるノードはちょうど$#stack[0]#,\ldots,#stack[k]#$である。
次のコードはこの#add(x)#アルゴリズムの実装である。
\label{pg:skiplist-add}
\codeimport{ods/SkiplistSSet.add(x)}

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-add}
  \end{center}
  \caption[Adding to a skiplist]{Adding the node containing $3.5$ to a skiplist.  The nodes stored in #stack#
  are highlighted.}
  \figlabel{skiplist-add}
\end{figure}

要素#x#を削除するのも同様に行える。ただし#stack#で探索経路を覚えておく必要はない。
削除は探索経路を辿ることで行える。
#x#を探す途中にノード#u#から下に向かうとき、$#u.next.x#=#x#$なら#u#を繋ぎ替える。
\codeimport{ods/SkiplistSSet.remove(x)}

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-remove}
  \end{center}
  \caption{Removing the node containing $3$ from a skiplist.}
  \figlabel{skiplist-remove}
\end{figure}

\subsection{Summary}

次の定理はスキップリストを使った整列集合の性能をまとめたものだ。

\begin{thm}\thmlabel{skiplist}
#SkiplistSSet#は#SSet#インターフェースの実装である。
#SkiplistSSet#は操作#add(x)#・#remove(x)#・#find(x)#を持ち、いずれの期待実行時間も$O(\log #n#)$である。
\end{thm}

\section{#SkiplistList#：効率的なランダムアクセス#List#}
\seclabel{skiplistlist}

\index{SkiplistList@#SkiplistList#}%
#SkiplistList#はスキップリストを使った#List#インターフェースの実装だ。
#SkiplistList#では、$L_0$はリストの要素をリストにおける順序通りに含む。
#SkiplistSSet#と同様に、要素の追加・削除・読み書きのいずれの実行時間も$O(\log #n#)$である。

これを可能にするためにはまず$L_0$における#i#番目の要素を見つける方法が必要だ。
このための最も簡単な方法はリスト$L_{#r#}$における\emph{辺の長さ}を定義することだ。
$L_{0}$における辺の長さをいずれも1とする。
$L_{#r#} (#r#>0)$の辺#e#の辺の長さを、$L_{#r#-1}$において#e#の下にある辺の長さの和とする。
これは辺#e#の長さは$L_0$において#e#の下にある辺の数であるとするのと等価な定義である。
この定義の例として\figref{skiplist-lengths}を参照せよ。
スキップリストの辺は配列に格納されており、その長さも同様に格納すればよい。

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-lengths}
  \end{center}
  \caption{The lengths of the edges in a skiplist.}
  \figlabel{skiplist-lengths}
\end{figure}

\javaimport{ods/SkiplistList.Node}
\cppimport{ods/SkiplistList.Node}

この定義の良い性質として、$L_0$においてj番目のノードから長さ$\ell$の辺を辿ると、$L_0$において$#j#+\ell$のノードに移るというものがある。
こうして、探索パスを辿りながら$L_0$におけるインデックス#j#を算出することができる。
$L_{#r#}$のノード#u#にいるとき、辺#u.next[r]#の長さと#j#の和が#i#より小さいなら右に進む。
そうでないな下、すなわち$L_{#r#-1}$に進む。

\codeimport{ods/SkiplistList.findPred(i)}
\codeimport{ods/SkiplistList.get(i).set(i,x)}

#get(i)#・#set(i,x)#において大変なのは$L_0$の#i#番目のノードを見つける処理なので、これらの処理の実行時間は$O(\log #n#)$である。

#SkiplistList#の#i#番目の位置に要素を追加するのは簡単だ。
#SkiplistSSet#とは違い新しいノードが必ず追加されるので、ノードの位置を見つける処理とノードを追加する処理を同時に実行できる。
まずは新たに挿入するノード#w#の高さ#k#を決め、#i#の探索経路を辿る。
$L_{#r#}$から下に進むのは$#r#\le #k#$のときで、このとき#w#を$L_{#r#}$と次合わせる。
このとき辺の長さも適切に更新する必要があることに注意する。
\figref{skiplist-addix}を見よ。

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-addix}
  \end{center}
  \caption[Adding to a SkiplistList]{Adding an element to a #SkiplistList#.}
  \figlabel{skiplist-addix}
\end{figure}

探索経路上の
探索経路上でリスト$L_{#r#}$のノード#u#に探索経路上で下ったとき、
#i#番目の位置に要素を追加することがわかるため辺#u.next[r]#の長さをひとつ大きくする。
ノード#w#をふたつのノード#u#と#z#の間に追加する様子が\figref{skiplist-lengths-splice}に示されている。
探索経路を辿りながら$L_0$において#u#が何番目なのかを数えることができる。
そのため#u#から#w#までの辺の長さは$#i#-#j#$とわかる。
さらに、#u#から#z#への辺の長さ$\ell$から、#w#から#z#への辺の長さを計算できる。
こうして#w#を挿入し、関連する辺の長さの更新を定数時間で終えることができる。

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/skiplist-lengths-splice}
  \end{center}
  \caption[Adding to a SkiplistList]{Updating the lengths of edges while splicing a node 
   #w# into a skiplist.}
  \figlabel{skiplist-lengths-splice}
\end{figure}

複雑そうに聞こえるかもしれないが、実際のコードはとても単純である。

\codeimport{ods/SkiplistList.add(i,x)}
\codeimport{ods/SkiplistList.add(i,w)}

ここまでの話から#SkiplistList#における#remove(i)#の実装は明らかである。
#i#番目の位置への探索経路を辿る。
高さ#r#のノード#u#から経路が下に向かうとき、その高さにおける#u#から出る辺の長さをひとつ小さくする。
また、#u.next[r]#が高さ#i#の要素であるかどうかを確認し、もしそうならリストからそれを除く。
\figref{skiplist-removei}に例が描かれている。

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-removei}
  \end{center}
  \caption[Removing an element from a SkiplistList]{Removing an element from a #SkiplistList#.}
  \figlabel{skiplist-removei}
\end{figure}
\codeimport{ods/SkiplistList.remove(i)}

\subsection{Summary}

次の定理は#SkiplistList#の性能をまとめたものだ。

\begin{thm}\thmlabel{skiplistlist}
  #SkiplistList#は#List#インターフェースを実装する。
  #SkiplistList#における#get(i)#・#set(i,x)#・#add(i,x)#・#remove(i)#の期待実行時間はいずれも$O(\log #n#)$である。
\end{thm}

\section{スキップリストの解析}
\seclabel{skiplist-analysis}

この節では高さ・大きさ・探索経路の長さの期待値を解析する。
ここでは基本的な確率論の知識を前提とする。
いくつかの証明はコイントスについての次に述べる考察を利用する。

\begin{lem}\lemlabel{coin-tosses}
  \index{coin toss}%
  $T$を表裏が等しい確率で出るコインを投げて、表が出るまでに要するコイントスの回数とする。（表が出た回も含めて数えることに注意する。）
\end{lem}

\begin{proof}
表が出たらにコイントスをやめるとする。
次の指示変数を定義する。
  \[ I_{i} = \left\{\begin{array}{ll}
     0 & \mbox{コイントスが$i$回よりも少ないとき} \\
     1 & \mbox{コイントスが$i$回以上のとき}
     \end{array}\right.
  \]
  $I_i=1$なのは最初の$i-1$回の結果がいずれも裏であることと同値である。
  よって$\E[I_i]=\Pr\{I_i=1\}=1/2^{i-1}$である。
  コイントスの合計回数$T$は$T=\sum_{i=1}^{\infty} I_i$と書ける。
  以上より、次のことがわかる。
  \begin{align*}
    \E[T] & =  \E\left[\sum_{i=1}^\infty I_i\right] \\
     & =  \sum_{i=1}^\infty \E\left[I_i\right] \\
     & =  \sum_{i=1}^\infty 1/2^{i-1} \\
     & =  1 + 1/2 + 1/4 + 1/8 + \cdots \\
     & =  2 \enspace .   \qedhere
  \end{align*}
\end{proof}

次のふたつの補題からスキップリストの大きさは要素数に対して線形だとわかる。

\begin{lem}\lemlabel{skiplist-size1}
  $#n#$要素からなるスキップリストにおける（番兵を除く）ノード数の期待値は $2#n#$である。
\end{lem}

\begin{proof}
  要素#x#がリスト$L_{#r#}$に含まれる確率は$1/2^{#r#}$である。
  よって$L_{#r#}$のノード数の期待値は$#n#/2^{#r#}$である。
  \footnote{\secref{指示変数と期待値の線形性からこの結果を得る方法はrandomization}を参照せよ。}
  以上よりすべてのリストに含まれるノードの総数の期待値が求まる。
  \[ \sum_{#r#=0}^\infty #n#/2^{#r#} = #n#(1+1/2+1/4+1/8+\cdots) = 2#n# \enspace . \qedhere \]
\end{proof}

\begin{lem}\lemlabel{skiplist-height}
  #n#要素を含むスキップリストの高さの期待値は$\log #n# + 2$以下である。
\end{lem}

\begin{proof}
  $#r#\in\{1,2,3,\ldots,\infty\}$について次の確率変数を定義する。
  \[ I_{#r#} = \left\{\begin{array}{ll}
     0 & \mbox{$L_{#r#}$が空のとき} \\
     1 & \mbox{$L_{#r#}$が空でないとき}
     \end{array}\right.
  \]
  スキップリストの高さ#h#は次のように計算できる。
  \[
       #h# = \sum_{r=1}^\infty I_{#r#} \enspace .
  \]
  $I_{#r#}$はリスト$L_{#r#}$の長さ$|L_{#r#}|$を越えないことに注意する。
  \[
     \E[I_{#r#}] \le \E[|L_{#r#}|] = #n#/2^{#r#} \enspace
  \]
  よって
  \begin{align*}
       \E[#h#] &= \E\left[\sum_{r=1}^\infty I_{#r#}\right] \\
        &= \sum_{#r#=1}^{\infty} E[I_{#r#}] \\
        &= \sum_{#r#=1}^{\lfloor\log #n#\rfloor} E[I_{#r#}]
                 + \sum_{r=\lfloor\log #n#\rfloor+1}^{\infty} E[I_{#r#}]  \\
        &\le \sum_{#r#=1}^{\lfloor\log #n#\rfloor} 1
                 + \sum_{r=\lfloor\log #n#\rfloor+1}^{\infty} #n#/2^{#r#} \\
        &\le \log #n#
                 + \sum_{#r#=0}^\infty 1/2^{#r#} \\
        &= \log #n# + 2 \enspace . \qedhere
  \end{align*}
\end{proof}

\begin{lem}\lemlabel{skiplist-size2}
  $#n#$要素からなるスキップリストのノード数の期待値は、番兵を含めて$2#n#+O(\log #n#)$である。
\end{lem}

\begin{proof}
  \lemref{skiplist-size1}より番兵を含まないノード数の期待値は$2#n#$である。
  番兵の数の期待値はスキップリストの高さ$#h#$に等しく、
  これは\lemref{skiplist-height}より$\log #n#+2 = O(\log #n#)$以下である。
  \end{proof}



\begin{lem}
スキップリストにおける探索経路の長さの期待値は$2\log #n# + O(1)$以下である。
\end{lem}

\begin{proof}
最も簡単な方法はノード#x#の\emph{逆探索経路}を考えることだ。
この経路は$L_0$における#x#の直前のノードから始まる。
パスが上に向かえるときはそうする。
そうでないなら左に進む。
少し考えると、#x#の逆探索経路は探索経路と方向が逆であることを除いて同じであることがわかるだろう。

ある高さで逆探索経路が通過するノードの数#r#は次の試行と関連している。
コインを投げる。
表が出れば上に向かい停止する。
裏が出れば左に向かい試行を続ける。
このとき、表が出るまでにコインを投げる回数は逆探索経路のある高さで左に向かうステップの数に対応している。
\footnote{これは大きく数えてしまうかもしれない。なぜなら試行は表が出るか番兵に出くわすかのどちらかが起きたときに終わるからである。しかしこれは問題ではない。なぜなら今考えている補題は上界に関するものだからである。}
\lemref{coin-tosses}よりはじめて表が出るまでのコイントスの回数の期待値は1である。

$S_{#r#}$を（順方向の）探索経路における高さ$#r#$で右に進む回数を表す。
$\E[S_{#r#}]\le 1$である。
さらに$L_{#r#}$では$L_{#r#}$の長さより多く右に進むことはないので$S_{#r#}\le |L_{#r#}|$である。
よって次の式が成り立つ。
  \[
    \E[S_{#r#}] \le \E[|L_{#r#}|] = #n#/2^{#r#} \enspace
  \]
あとは\lemref{skiplist-height}と同様に証明を完成できる。
$S$をスキップリストにおけるノード#u#の探索経路の長差とする。
また、#h#をそのスキップリストの高さとする。
このとき、次の式が成り立つ。
  \begin{align*}
      \E[S] 
         &= \E\left[ #h# + \sum_{#r#=0}^\infty S_{#r#} \right] \\
         &= \E[#h#] + \sum_{#r#=0}^\infty \E[S_{#r#}]  \\
         &= \E[#h#] + \sum_{#r#=0}^{\lfloor\log #n#\rfloor} \E[S_{#r#}] 
              + \sum_{#r#=\lfloor\log #n#\rfloor+1}^\infty \E[S_{#r#}] \\
         &\le \E[#h#] + \sum_{#r#=0}^{\lfloor\log #n#\rfloor} 1
              + \sum_{r=\lfloor\log #n#\rfloor+1}^\infty #n#/2^{#r#} \\
         &\le \E[#h#] + \sum_{#r#=0}^{\lfloor\log #n#\rfloor} 1
              + \sum_{#r#=0}^{\infty} 1/2^{#r#} \\
         &\le \E[#h#] + \sum_{#r#=0}^{\lfloor\log #n#\rfloor} 1
              + \sum_{#r#=0}^{\infty} 1/2^{#r#} \\
         &\le \E[#h#] + \log #n# + 3 \\
         &\le 2\log #n# + 5  \enspace . \qedhere
  \end{align*}
\end{proof}


次の定理はこの節の結果をまとめるものだ。
\begin{thm}
$#n#$要素を含むスキップリストの大きさの期待値は$O(#n#)$である。
ある要素の探索経路の長さの期待値は$2\log #n# + O(1)$以下である。
\end{thm}

