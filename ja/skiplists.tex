\chapter{スキップリスト}
\chaplabel{skiplists}

この章ではスキップリストという面白くて実際の応用も多いデータ構造を紹介する。
スキップリストは#get(i)#・#set(i,x)#・#add(i,x)#・#remove(i)#をいずれも$O(\log n)$の時間で実行できる#List#の実装である。
#SSet#の実装でもあり、すべての操作の期待実行時間は$O(\log #n#)$である。

スキップリストの効率性のキモはランダム性である。
新しい要素を追加するとき、スキップリストではランダムにコインを投げて要素の高さを決める。
スキップリストの性能は期待実行時間とパス長を使って表現できる。
コイントスの結果に応じて決まる確率からこの期待値は計算される。
ランダムなコイントスは擬似乱数（あるいはランダムビット）生成器によるシミュレーションで実装される。

\section{基本的な構造}

\index{skiplist}%
イメージとしてはスキップリストは単方向連結リストが並んだもの$L_0,\ldots,L_h$である。
リスト$L_r$は$L_{r-1}$の部分集合を含む。
まず#n#個の要素を含む入力$L_0$がある。
$L_0$から$L_1$を作り、$L_1$から$L_2$を作り、というのを繰り返す。
$L_{r-1}$の各要素についてコインを投げ、表が出たら$L_r$はこれを含む。
リスト$L_r$が空ならこの繰り返しを終える。
スキップリストの例を\figref{skiplist}に示した。

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist}
  \end{center}
  \caption{A skiplist containing seven elements.}
  \figlabel{skiplist}
\end{figure}

スキップリストの要素#x#について、#x#の\emph{高さ}を
For an element, #x#, in a skiplist, we call the \emph{height}
\index{height!of a skiplist}%
#x#を含むリスト$L_r$の添え字#r#のうち最大のものと定義する。
例えば#x#が$L_0$だけに含まれているなら#x#の高さは$0$である。
少し考えると#x#は次の試行と関連していることがわかるだろう。

コインを裏が出るまで繰り返し投げる。表は何回出るだろうか。
この答え、そして高さの期待値は1である。（コイントスの回数の期待値は2回だが、最後のトスは表でないため表が出る回数の期待値は1だ。）
スキップリストの\emph{高さ}とは、最も高いノードの高さである。

すべてのリストの先頭は特別で、\emph{番兵}と呼ばれる。
\index{sentinel node}%
これはリストのダミーノードのようなものだ。
スキップリストの重要な性質は、\emph{探索経路}と呼ばれる
\index{search path!in a skiplist}%
$L_h$の番兵から$L_0$の各ノードまでの短いパスが存在することだ。
ノード#u#へのパスの作り方は簡単だ。（\figref{skiplist-searchpath}を参照のこと。）
左上の端（$L_h$の番兵）からスタートし、#u#を通り過ぎない限り右に進む。
#u#を通り過ぎてしまう場合はその代わりに下に進む。

もうすこし正確に説明する。
$L_h$の番兵#w#から$L_0$のノード#u#への探索経路を見つける。
まず#w.next#を見て、これが$L_0$の中で#u#より前にあれば$#w#=#w.next#$とする。
そうでなければ、ひとつ下のリストに下がり、$L_{h-1}$の#w#から処理を続ける。
これを$L_0$における#u#の直前の要素にたどり着くまで繰り返す。
\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-searchpath}
  \end{center}
  \caption{The search path for the node containing $4$ in a skiplist.}
  \figlabel{skiplist-searchpath}
\end{figure}

次の補題はsecref{skiplist-analysis}で証明するが、探索経路が非常に短いことを主張する。

\begin{lem}\lemlabel{skiplist-searchpath}
$L_0$の任意のノード#u#への探索経路の長さの期待値は$2\log #n# + O(1) = O(\log #n#)$以下である。
\end{lem}

空間効率のよいスキップリストの実装方法を説明する。
ノード#u#はデータ#x#・ポインタの配列#next#を含む。
#u.next[i]#で$L_{#i#}$における#u#の次のノードを指せばよい。
こうすると#x#は複数のリストに現れるかもしれないが、ノードとしての実体はひとつだけあれば済む。

\javaimport{ods/SkiplistSSet.Node<T>}
\cppimport{ods/SkiplistSSet.Node}

この章の続くふたつの節ではスキップリストの応用をそれぞれ紹介する。
そこでは$L_0$が主な構造（リストや整列された集合）を保持する。
違いはどのように探索経路を辿り方である。
下に進んで$L_{r-1}$に移るか、$L_r$の中で右に進むかの選び方に違いがあるのである。

\section{#SkiplistSSet#：効率的な#SSet#}
\seclabel{skiplistset}

\index{SkiplistSSet@#SkiplistSSet#}%
#SkiplistSSet#はスキップリストを使った#SSet#インターフェースの実装である。
ここでは、$L_0$は#SSet#の要素を整列して格納する。
#find(x)#は探索経路に沿って$#y#\ge#x#$を満たす最小の#y#を探す。

\codeimport{ods/SkiplistSSet.find(x).findPredNode(x)}

#y#の探索経路を辿るのは簡単だ。
$L_{#r#}$の中のノード#u#にいるとすると、まず右隣#u.next[r].x#を見る。
$#x#>#u.next[r].x#$なら$L_{#r#}$の中で右に進む。
そうでないなら$L_{#r#-1}$に下がる。
各ステップ（右または下に進む）は一定の時間で実行できる。
よって\lemref{skiplist-searchpath}より#find(x)#の期待実行時間は$O(\log #n#)$である。

#SkipListSSet#に要素を追加する方法の前に、新しいノードの高さ#k#を決めるためのコイントスをシミュレートする方法を考える。
ランダムな整数#z#を生成し、#z#の2進数表現において連続する1の数を数える。
\footnote{この方法はコイントスを完全に再現しているわけではない。なぜなら#k#は#int#のビット数より常に小さいからである。しかし要素数が$2^{32}=4294967296$を越える場合でもない限り、この影響は無視できるほど小さい。}

\codeimport{ods/SkiplistSSet.pickHeight()}

#SkiplistSSet#の#add(x)#の実装は、#x#を入れる場所を見つけ、高さ#k#を#pickHeight()#で決め、#x#を$L_0$,\ldots,$L_{#k#}$に継ぎ合せる。
これを実現する最も簡単な方法は、リスト$L_{#r#}$からリスト$L_{#r#-1}$に下がるノードを記録する配列#stack#を使うことだ。
より正確にいうと、#stack[r]#は$L_{#r#}$内の$L_{#r#-1}$に下がるパスのあるノードである。
#x#を挿入する時に修正する必要のあるノードはちょうど$#stack[0]#,\ldots,#stack[k]#$である。
次のコードはこの#add(x)#アルゴリズムの実装である。
\label{pg:skiplist-add}
\codeimport{ods/SkiplistSSet.add(x)}

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-add}
  \end{center}
  \caption[Adding to a skiplist]{Adding the node containing $3.5$ to a skiplist.  The nodes stored in #stack#
  are highlighted.}
  \figlabel{skiplist-add}
\end{figure}

要素#x#を削除するのも同様に行える。ただし#stack#で探索経路を覚えておく必要はない。
削除は探索経路を辿ることで行える。
#x#を探す途中にノード#u#から下に向かうとき、$#u.next.x#=#x#$なら#u#を繋ぎ替える。
\codeimport{ods/SkiplistSSet.remove(x)}

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-remove}
  \end{center}
  \caption{Removing the node containing $3$ from a skiplist.}
  \figlabel{skiplist-remove}
\end{figure}

\subsection{Summary}

次の定理はスキップリストを使った整列集合の性能をまとめたものだ。

\begin{thm}\thmlabel{skiplist}
#SkiplistSSet#は#SSet#インターフェースの実装である。
#SkiplistSSet#は操作#add(x)#・#remove(x)#・#find(x)#を持ち、いずれの期待実行時間も$O(\log #n#)$である。
\end{thm}

